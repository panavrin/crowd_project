{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar Fiber, Future, LogicalOps, _monkeyPatch, _submitOpMonkeyPatched, runValidations,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nFiber = Npm.require('fibers');\n\nFuture = Npm.require('fibers/future');\n\nLogicalOps = {\n  'or': function(a, b) {\n    return a || b;\n  },\n  'and': function(a, b) {\n    return a && b;\n  }\n};\n\nrunValidations = function(currentOp, validations, doc, token) {\n  var k, lookIn, nestedResult, result, v;\n  if (currentOp === null) {\n    if ((validations != null ? validations.or : void 0) != null) {\n      return runValidations(\"or\", validations.or, doc, token);\n    } else if ((validations != null ? validations.and : void 0) != null) {\n      return runValidations(\"and\", validations.and, doc, token);\n    } else if (validations != null) {\n      return runValidations(\"and\", validations, doc, token);\n    } else {\n      return true;\n    }\n  } else if (currentOp != null) {\n    if (currentOp === \"or\") {\n      result = false;\n    } else if (currentOp = \"and\") {\n      result = true;\n    }\n    for (k in validations) {\n      v = validations[k];\n      if (k === \"or\" || k === \"and\") {\n        nestedResult = runValidations(k, v, doc, token);\n        result = LogicalOps[currentOp](result, nestedResult);\n      } else {\n        switch (v) {\n          case \"is_in_array\":\n            result = LogicalOps[currentOp](result, indexOf.call(doc[k], token) >= 0);\n            break;\n          case \"isnt_in_array\":\n            lookIn = doc.k || [];\n            result = LogicalOps[currentOp](result, indexOf.call(doc[k], token) < 0);\n            break;\n          case \"is_equal\":\n            result = LogicalOps[currentOp](result, token === doc[k]);\n            break;\n          case \"isnt_equal\":\n            result = LogicalOps[currentOp](result, token === !doc[k]);\n        }\n      }\n    }\n    return result;\n  }\n};\n\n_submitOpMonkeyPatched = false;\n\n_monkeyPatch = function(agent) {\n  var UserAgent, model;\n  UserAgent = Object.getPrototypeOf(agent);\n  model = ShareJS.model;\n  UserAgent.submitOp = function(docName, opData, callback) {\n    var dupIfSource;\n    opData.meta || (opData.meta = {});\n    opData.meta.userId = this.name;\n    opData.meta.source = this.sessionId;\n    dupIfSource = opData.dupIfSource || [];\n    if (opData.op) {\n      return this.doAuth({\n        docName: docName,\n        op: opData.op,\n        v: opData.v,\n        meta: opData.meta,\n        dupIfSource: dupIfSource\n      }, 'submit op', callback, (function(_this) {\n        return function() {\n          return model.applyOp(docName, opData, callback);\n        };\n      })(this));\n    } else {\n      return this.doAuth({\n        docName: docName,\n        meta: opData.meta\n      }, 'submit meta', callback, (function(_this) {\n        return function() {\n          return model.applyMetaOp(docName, opData, callback);\n        };\n      })(this));\n    }\n  };\n  console.log(\"ShareJS: patched UserAgent submitOp function to record Meteor userId\");\n  return _submitOpMonkeyPatched = true;\n};\n\nthis.MeteorAccountsAuthHandler = (function() {\n  function MeteorAccountsAuthHandler(options, client) {\n    this.options = options;\n    this.client = client;\n    this.handle = bind(this.handle, this);\n  }\n\n  MeteorAccountsAuthHandler.prototype.fetchDocument = function(collection, key) {\n    var future;\n    future = new Future;\n    this.client.collection(collection, function(err, collection) {\n      if (err) {\n        return future[\"throw\"](err);\n      }\n      return collection.findOne({\n        _id: key\n      }, function(err, doc) {\n        if (err) {\n          console.warn(\"failed to get doc in \" + collection + \" with key \" + key + \": \" + err);\n        }\n        if (err) {\n          future[\"throw\"](null);\n        }\n        return future[\"return\"](doc);\n      });\n    });\n    return future;\n  };\n\n  MeteorAccountsAuthHandler.prototype.getAuthentication = function(agent) {\n    var collection, future, token, user, validations;\n    token = agent.authentication;\n    validations = this.options.authenticate.token_validations;\n    collection = this.options.authenticate.collection;\n    future = new Future;\n    user = this.fetchDocument(collection, agent.authentication).wait();\n    if (!((user != null) || ((validations.or != null) && (validations.and != null)))) {\n      future[\"return\"](false);\n    }\n    future[\"return\"](runValidations(null, validations, user, token));\n    return future;\n  };\n\n  MeteorAccountsAuthHandler.prototype.getAuthorization = function(agent, action) {\n    var collection, doc, future, token, validations;\n    token = agent.authentication;\n    validations = this.options.authorize.token_validations;\n    collection = this.options.authorize.collection;\n    future = new Future;\n    doc = this.fetchDocument(collection, action.docName).wait();\n    if (!((doc != null) || ((validations.or != null) && (validations.and != null)))) {\n      future[\"return\"](false);\n    }\n    future[\"return\"](runValidations(null, validations, doc, token));\n    return future;\n  };\n\n  MeteorAccountsAuthHandler.prototype.handle = function(agent, action) {\n    var authenticate, authorize, opsToAuthorize, ref;\n    if (!_submitOpMonkeyPatched) {\n      _monkeyPatch(agent);\n    }\n    authenticate = this.options.authenticate != null;\n    authorize = this.options.authorize != null;\n    opsToAuthorize = (ref = this.options.authorize) != null ? ref.apply_on : void 0;\n    return (Fiber(((function(_this) {\n      return function() {\n        var ref1, res;\n        res = false;\n        if (authenticate && (action.type === \"connect\")) {\n          res = _this.getAuthentication(agent).wait();\n          if (res) {\n            agent.name = agent.authentication;\n          }\n        } else if (authorize && (ref1 = action.type, indexOf.call(opsToAuthorize, ref1) >= 0)) {\n          res = _this.getAuthorization(agent, action).wait();\n        } else {\n          res = true;\n        }\n        if (res) {\n          return action.accept();\n        } else {\n          return action.reject();\n        }\n      };\n    })(this)))).run();\n  };\n\n  return MeteorAccountsAuthHandler;\n\n})();\n","sourceMap":{"version":3,"file":"/sharejs-meteor-auth.coffee.js","sourceRoot":"","sources":["/packages/mizzao_sharejs/sharejs-meteor-auth.coffee"],"names":[],"mappings":"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","sourcesContent":["# Auth API helpers\nFiber = Npm.require('fibers');\nFuture = Npm.require('fibers/future')\n\n# Metaprogramming aids\nLogicalOps =\n    'or'  : (a, b) -> a or b\n    'and' : (a, b) -> a and b\n\n# Recursively evaluate the validations provided in settings.json\nrunValidations = (currentOp, validations, doc, token) ->\n  if currentOp is null\n    if validations?.or?\n      # recurse into or\n      return runValidations(\"or\", validations.or, doc, token)\n    else if validations?.and?\n      # recurse into and\n      return runValidations(\"and\", validations.and, doc, token)\n    else if validations?\n      # If no higher level \"or\" and \"and\", default to \"and\"\n      return runValidations(\"and\", validations, doc, token)\n    else\n      # No validations being asked to run - user possibly just wants to check\n      # for presence of user/doc\n      return true\n  else if currentOp?\n    if currentOp is \"or\"\n      result = false\n    else if currentOp = \"and\"\n      result = true\n\n    for k, v of validations\n      if k in [\"or\", \"and\"]\n        # recurse into or/and\n        nestedResult = runValidations(k, v, doc, token)\n        result = LogicalOps[currentOp](result, nestedResult)\n      else\n        switch v\n          when \"is_in_array\"\n            result = LogicalOps[currentOp](result, token in doc[k])\n          when \"isnt_in_array\"\n            lookIn = doc.k or []\n            result = LogicalOps[currentOp](result, token not in doc[k])\n          when \"is_equal\"\n            result = LogicalOps[currentOp](result, token is doc[k])\n          when \"isnt_equal\"\n            result = LogicalOps[currentOp](result, token is not doc[k])\n    return result\n\n_submitOpMonkeyPatched = false\n\n_monkeyPatch = (agent) ->\n  UserAgent = Object.getPrototypeOf(agent)\n  model = ShareJS.model\n  # Overriding https://github.com/share/ShareJS/blob/v0.6.2/src/server/useragent.coffee,\n  # including variables in closure. >.< @josephg\n  UserAgent.submitOp = (docName, opData, callback) ->\n    opData.meta ||= {}\n    opData.meta.userId = @name\n    opData.meta.source = @sessionId\n    dupIfSource = opData.dupIfSource or []\n\n    # If ops and meta get coalesced, they should be separated here.\n    if opData.op\n      @doAuth {docName, op:opData.op, v:opData.v, meta:opData.meta, dupIfSource}, 'submit op', callback, =>\n        model.applyOp docName, opData, callback\n    else\n      @doAuth {docName, meta:opData.meta}, 'submit meta', callback, =>\n        model.applyMetaOp docName, opData, callback\n\n  console.log \"ShareJS: patched UserAgent submitOp function to record Meteor userId\"\n  _submitOpMonkeyPatched = true\n\n# Based on https://github.com/share/ShareJS/wiki/User-access-control\nclass @MeteorAccountsAuthHandler\n  constructor: (@options, @client) ->\n\n  # Get a future that resolves to the entry from the database for given query\n  fetchDocument: (collection, key) ->\n    future = new Future\n    @client.collection collection, (err, collection) ->\n      return future.throw(err) if err\n\n      collection.findOne {_id: key}, (err, doc) ->\n        console.warn \"failed to get doc in #{collection} with key #{key}: #{err}\" if err\n        future.throw(null) if err\n        future.return(doc)\n\n    return future\n\n  # Get a future that would resolve to authentication as a bool\n  getAuthentication: (agent) ->\n    token = agent.authentication\n    validations = @options.authenticate.token_validations\n    collection = @options.authenticate.collection\n\n    future = new Future\n\n    user = @fetchDocument(collection, agent.authentication).wait()\n    # Not having user necessitates bailing out!\n    # Having both \"and\" and \"or\" on the top level is not allowed\n    unless user? or (validations.or? and validations.and?)\n      future.return false\n\n    future.return runValidations(null, validations, user, token)\n\n    return future\n\n  # Get a future that would resolve to authorization as a bool\n  getAuthorization: (agent, action) ->\n    token = agent.authentication\n    validations = @options.authorize.token_validations\n    collection = @options.authorize.collection\n\n    future = new Future\n\n    doc = @fetchDocument(collection, action.docName).wait()\n    # Not having document necessitates bailing out!\n    # Having both \"and\" and \"or\" on the top level is not allowed\n    unless doc? or (validations.or? and validations.and?)\n      future.return false\n\n    future.return runValidations(null, validations, doc, token)\n\n    return future\n\n  handle: (agent, action) =>\n    # This is ugly, but we have no other way to store Meteor usernames in ShareJS 0.6.2\n    _monkeyPatch(agent) unless _submitOpMonkeyPatched\n\n    authenticate = @options.authenticate?\n    authorize = @options.authorize?\n    opsToAuthorize = @options.authorize?.apply_on\n\n    (Fiber (=>\n      res = false\n\n      if authenticate and (action.type is \"connect\")\n        res = @getAuthentication(agent).wait()\n        # Save Meteor userId if we successfully authenticated\n        agent.name = agent.authentication if res\n\n      else if authorize and action.type in opsToAuthorize\n        res = @getAuthorization(agent, action).wait()\n      else\n        # Accept all other actions\n        res = true\n\n      if res\n        action.accept()\n      else\n        action.reject()\n    )).run()\n"]}}